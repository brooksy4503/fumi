import { NextResponse } from 'next/server';
import { FAL_KEY } from '@/utils/fal';
import { fal } from '@fal-ai/client';
import { getModel, modelExists, getDefaultParams, validateInput } from '@/registry/model-registry';
import {
  ModelMetadata,
  ModelInput,
  ModelOutput,
  ImageGenerationInput,
  VideoGenerationInput,
  TextToSpeechInput,
  SpeechToTextInput,
  AudioGenerationInput,
  ImageEditingInput,
  FalRequest,
  FalResponse
} from '@/types/fal-models';

// Define types for the FAL API response
interface FalImage {
  url: string;
  [key: string]: any; // For other potential properties
}

interface FalApiResponse {
  data?: {
    images?: FalImage[];
    videos?: any[];
    video?: any;
    audio?: any;
    text?: string;
    transcription?: string;
    [key: string]: any;
  };
  requestId?: string;
  [key: string]: any; // For other potential properties
}

/**
 * Validates the response from FAL API based on model category
 */
function validateResponse(category: string, response: FalApiResponse): string | null {
  if (!response) {
    return 'No response received from model';
  }

  switch (category) {
    case 'image-generation':
      if (!response.data?.images || response.data.images.length === 0) {
        return 'No images returned in response';
      }
      break;

    case 'video-generation':
      if (!response.data?.videos && !response.data?.video) {
        return 'No video content returned in response';
      }
      break;

    case 'text-to-speech':
    case 'audio-generation':
      if (!response.data?.audio) {
        return 'No audio content returned in response';
      }
      break;

    case 'speech-to-text':
      if (!response.data?.text && !response.data?.transcription) {
        return 'No text content returned in response';
      }
      break;

    default:
      // For other categories, just check if there's any data
      if (!response.data) {
        return 'No data returned in response';
      }
  }

  return null; // Validation passed
}

export async function POST(request: Request) {
  const startTime = Date.now();

  try {
    console.log('Starting dynamic model generation process');

    const body = await request.json();
    const { model: modelId, ...inputParams } = body;

    // Validate required parameters
    if (!modelId) {
      console.error('Missing model ID in request');
      return NextResponse.json({ error: 'Model ID is required' }, { status: 400 });
    }

    console.log('Requested model:', modelId);
    console.log('Input parameters:', JSON.stringify(inputParams, null, 2));
    console.log('DEBUG: Model ID format analysis:');
    console.log('  - Raw modelId:', modelId);
    console.log('  - Contains slash:', modelId.includes('/'));
    console.log('  - Split parts:', modelId.split('/'));
    console.log('  - Length:', modelId.split('/').length);

    // Check if model exists in registry
    if (!modelExists(modelId)) {
      console.error('Model not found in registry:', modelId);
      return NextResponse.json({
        error: `Model '${modelId}' not found in registry`,
        availableModels: ['stability-ai/stable-diffusion-xl-1.0', 'openai/dall-e-3', 'fal-ai/flux/schnell', 'openai/sora', 'runwayml/gen-2', 'openai/tts', 'elevenlabs/tts', 'openai/whisper-large-v3', 'facebook/musicgen-large']
      }, { status: 400 });
    }

    // Get model metadata
    const model = getModel(modelId);
    if (!model) {
      console.error('Failed to retrieve model metadata:', modelId);
      return NextResponse.json({ error: 'Failed to retrieve model metadata' }, { status: 500 });
    }

    console.log('Model metadata retrieved:', {
      name: model.name,
      category: model.category,
      provider: model.provider,
      version: model.version
    });

    if (!FAL_KEY) {
      console.error('FAL_KEY environment variable not found');
      return NextResponse.json(
        { error: 'FAL_KEY is not configured' },
        { status: 500 }
      );
    }

    // Validate input parameters against model requirements
    const validation = validateInput(modelId, inputParams as ModelInput);
    if (!validation.valid) {
      console.error('Input validation failed:', validation.errors);
      return NextResponse.json({
        error: 'Input validation failed',
        details: validation.errors
      }, { status: 400 });
    }

    console.log('Input validation passed');

    // Get default parameters and merge with provided input
    const defaultParams = getDefaultParams(modelId);
    const finalInput = {
      ...defaultParams,
      ...inputParams,
      // Ensure required fields are present based on model category
      ...(model.category === 'image-generation' && !inputParams.prompt && { prompt: 'default image prompt' }),
      ...(model.category === 'video-generation' && !inputParams.prompt && { prompt: 'default video prompt' }),
      ...(model.category === 'text-to-speech' && !inputParams.text && { text: 'default text to speech' }),
      ...(model.category === 'audio-generation' && !inputParams.prompt && { prompt: 'default audio prompt' })
    };

    console.log('Final input parameters:', JSON.stringify(finalInput, null, 2));

    // Configure FAL client
    console.log('Configuring FAL client with API key');
    fal.config({
      credentials: FAL_KEY
    });

    // Route to appropriate FAL endpoint based on model category
    console.log('Sending request to FAL API with model:', modelId);

    const result = await fal.subscribe(modelId, {
      input: finalInput,
      logs: true,
    });

    const processingTime = Date.now() - startTime;
    console.log('FAL API response received in', processingTime, 'ms');
    console.log('FAL API response:', JSON.stringify(result, null, 2));

    // Type assertion to work with the response
    const typedResult = result as FalApiResponse;

    // Validate response based on model category
    const validationError = validateResponse(model.category, typedResult);
    if (validationError) {
      console.error('Response validation failed:', validationError);
      return NextResponse.json({
        error: 'Invalid response from model',
        details: validationError,
        raw_response: typedResult
      }, { status: 500 });
    }

    // Return successful response with metadata
    const response = {
      ...typedResult,
      metadata: {
        model: modelId,
        modelName: model.name,
        category: model.category,
        provider: model.provider,
        processingTime,
        timestamp: new Date().toISOString()
      }
    };

    console.log('Returning successful response');
    return NextResponse.json(response);

  } catch (error) {
    const processingTime = Date.now() - startTime;
    console.error('Error in model generation:', error);

    // Enhanced error handling with more context
    let errorMessage = 'Failed to generate content';
    let errorDetails = null;
    let statusCode = 500;

    if (error instanceof Error) {
      errorMessage = error.message;
      errorDetails = {
        name: error.name,
        stack: error.stack,
        processingTime
      };

      // Determine if it's a client error (4xx) or server error (5xx)
      if (error.message.includes('validation') || error.message.includes('required')) {
        statusCode = 400;
      } else if (error.message.includes('not found') || error.message.includes('unauthorized')) {
        statusCode = 404;
      }
    }

    return NextResponse.json(
      {
        error: errorMessage,
        details: errorDetails,
        timestamp: new Date().toISOString()
      },
      { status: statusCode }
    );
  }
}
